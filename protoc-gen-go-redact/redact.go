package main

import (
	"fmt"

	redact "github.com/crypto-zero/go-kit/proto/kit/redact/v1"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

// generateFile generates a _redact.pb.go file containing Redact() method implementations.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Messages) == 0 {
		return nil
	}

	// Phase 1: Collect all messages that directly have redact fields
	messagesWithDirectRedact := make(map[string]bool)
	collectMessagesWithDirectRedact(file.Messages, messagesWithDirectRedact)

	// Phase 2: Propagate - mark messages that reference redactable messages
	messagesNeedRedact := make(map[string]bool)
	for name := range messagesWithDirectRedact {
		messagesNeedRedact[name] = true
	}
	propagateRedactRequirement(file.Messages, messagesNeedRedact)

	// Phase 3: Build message descriptors for code generation
	var messagesWithRedact []*messageDesc
	for _, msg := range file.Messages {
		collectMessagesForGeneration(msg, messagesNeedRedact, &messagesWithRedact)
	}

	if len(messagesWithRedact) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_redact.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-redact. DO NOT EDIT.")
	g.P("// versions:")
	g.P(fmt.Sprintf("// - protoc-gen-go-redact %s", release))
	g.P("// - protoc             ", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Import packages
	g.P("import (")
	g.P(`	"encoding/json"`)
	g.P()
	g.P(`	"google.golang.org/protobuf/encoding/protojson"`)
	g.P(`	"google.golang.org/protobuf/proto"`)
	g.P(")")
	g.P()

	for _, md := range messagesWithRedact {
		g.P(md.execute())
	}

	return g
}

// collectMessagesWithDirectRedact finds all messages that have fields directly marked with redact option.
func collectMessagesWithDirectRedact(messages []*protogen.Message, result map[string]bool) {
	for _, msg := range messages {
		if hasDirectRedactField(msg) {
			result[string(msg.Desc.FullName())] = true
		}
		// Recursively check nested messages
		collectMessagesWithDirectRedact(msg.Messages, result)
	}
}

// hasDirectRedactField checks if a message has any field directly marked with redact option.
func hasDirectRedactField(msg *protogen.Message) bool {
	for _, field := range msg.Fields {
		opts := field.Desc.Options().(*descriptorpb.FieldOptions)
		if opts != nil && proto.HasExtension(opts, redact.E_Redact) {
			redactOpts := proto.GetExtension(opts, redact.E_Redact).(*redact.RedactOptions)
			if redactOpts != nil && redactOpts.GetRedact() {
				return true
			}
		}
	}
	return false
}

// propagateRedactRequirement propagates the redact requirement up the message tree.
// If a message contains a field that references a message needing redact, it also needs redact.
func propagateRedactRequirement(messages []*protogen.Message, needsRedact map[string]bool) {
	changed := true
	// Keep iterating until no changes (fixed point)
	for changed {
		changed = false
		for _, msg := range messages {
			propagateForMessage(msg, needsRedact, &changed)
		}
	}
}

func propagateForMessage(msg *protogen.Message, needsRedact map[string]bool, changed *bool) {
	msgName := string(msg.Desc.FullName())

	// If already marked, skip
	if needsRedact[msgName] {
		// Still need to process nested messages
		for _, nested := range msg.Messages {
			propagateForMessage(nested, needsRedact, changed)
		}
		return
	}

	// Check if any message-type field references a message that needs redact
	for _, field := range msg.Fields {
		if field.Desc.Kind() == protoreflect.MessageKind {
			fieldMsgName := string(field.Desc.Message().FullName())
			if needsRedact[fieldMsgName] {
				needsRedact[msgName] = true
				*changed = true
				break
			}
		}
	}

	// Recursively process nested messages
	for _, nested := range msg.Messages {
		propagateForMessage(nested, needsRedact, changed)
	}
}

// collectMessagesForGeneration collects messages that need Redact() method generation.
func collectMessagesForGeneration(msg *protogen.Message, needsRedact map[string]bool, result *[]*messageDesc) {
	msgName := string(msg.Desc.FullName())
	if needsRedact[msgName] {
		if md := buildMessageDesc(msg); md != nil {
			*result = append(*result, md)
		}
	}

	// Recursively handle nested messages
	for _, nested := range msg.Messages {
		collectMessagesForGeneration(nested, needsRedact, result)
	}
}

// buildMessageDesc builds a messageDesc for code generation.
func buildMessageDesc(msg *protogen.Message) *messageDesc {
	var fields []*fieldDesc

	for _, field := range msg.Fields {
		isMessage := field.Desc.Kind() == protoreflect.MessageKind
		fd := &fieldDesc{
			GoName:     field.GoName,
			JSONName:   string(field.Desc.JSONName()),
			Redact:     false,
			Mask:       "*",
			IsMessage:  isMessage,
			IsRepeated: field.Desc.IsList(),
		}

		// Check for redact option using the generated extension
		opts := field.Desc.Options().(*descriptorpb.FieldOptions)
		if opts != nil && proto.HasExtension(opts, redact.E_Redact) {
			redactOpts := proto.GetExtension(opts, redact.E_Redact).(*redact.RedactOptions)
			if redactOpts != nil && redactOpts.GetRedact() {
				fd.Redact = true
				if redactOpts.GetMask() != "" {
					fd.Mask = redactOpts.GetMask()
				}
			}
		}

		fields = append(fields, fd)
	}

	return &messageDesc{
		Name:   msg.GoIdent.GoName,
		Fields: fields,
	}
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

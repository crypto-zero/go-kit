package main

import (
	"fmt"

	redact "github.com/crypto-zero/go-kit/proto/kit/redact/v1"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

// generateFile generates a _redact.pb.go file containing Redact() method implementations.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Messages) == 0 {
		return nil
	}

	// Collect all messages that have redact fields (including nested messages)
	var messagesWithRedact []*messageDesc
	for _, msg := range file.Messages {
		collectMessagesWithRedact(msg, &messagesWithRedact)
	}

	if len(messagesWithRedact) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_redact.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-redact. DO NOT EDIT.")
	g.P("// versions:")
	g.P(fmt.Sprintf("// - protoc-gen-go-redact %s", release))
	g.P("// - protoc             ", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Import packages
	g.P("import (")
	g.P(`	"encoding/json"`)
	g.P()
	g.P(`	"google.golang.org/protobuf/encoding/protojson"`)
	g.P(`	"google.golang.org/protobuf/proto"`)
	g.P(")")
	g.P()

	for _, md := range messagesWithRedact {
		g.P(md.execute())
	}

	return g
}

// collectMessagesWithRedact recursively collects all messages with redact fields.
func collectMessagesWithRedact(msg *protogen.Message, result *[]*messageDesc) {
	if md := buildMessageDesc(msg); md != nil {
		*result = append(*result, md)
	}
	// Recursively handle nested messages
	for _, nested := range msg.Messages {
		collectMessagesWithRedact(nested, result)
	}
}

// buildMessageDesc builds a messageDesc for code generation.
func buildMessageDesc(msg *protogen.Message) *messageDesc {
	var fields []*fieldDesc
	hasRedactField := false

	for _, field := range msg.Fields {
		fd := &fieldDesc{
			GoName:     field.GoName,
			JSONName:   string(field.Desc.JSONName()),
			Redact:     false,
			Mask:       "*",
			IsMessage:  field.Desc.Kind() == protoreflect.MessageKind,
			IsRepeated: field.Desc.IsList(),
		}

		// Check for redact option using the generated extension
		opts := field.Desc.Options().(*descriptorpb.FieldOptions)
		if opts != nil && proto.HasExtension(opts, redact.E_Redact) {
			redactOpts := proto.GetExtension(opts, redact.E_Redact).(*redact.RedactOptions)
			if redactOpts != nil && redactOpts.GetRedact() {
				fd.Redact = true
				hasRedactField = true
				if redactOpts.GetMask() != "" {
					fd.Mask = redactOpts.GetMask()
				}
			}
		}

		fields = append(fields, fd)
	}

	if !hasRedactField {
		return nil
	}

	return &messageDesc{
		Name:   msg.GoIdent.GoName,
		Fields: fields,
	}
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

// Code generated by protoc-gen-go-redact. DO NOT EDIT.
// versions:
// - protoc-gen-go-redact v1.0.0
// - protoc             v5.29.3
// source: example.proto

package testdata

import (
	"encoding/json"
	"fmt"

	"google.golang.org/protobuf/encoding/protojson"
)

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *User) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["id"] = x.Id
	m["name"] = x.Name
	m["email"] = "*"
	m["password"] = "[HIDDEN]"
	m["phone"] = "[PHONE]"
	m["age"] = x.Age
	return m
}

// Redact returns a redacted JSON string representation of User.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *User) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *Address) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["street"] = x.Street
	m["city"] = x.City
	m["state"] = x.State
	m["zipCode"] = "[ZIP]"
	m["country"] = x.Country
	return m
}

// Redact returns a redacted JSON string representation of Address.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *Address) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *Account) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["id"] = x.Id
	m["secretKey"] = "***SECRET***"
	if x.User != nil {
		if r, ok := any(x.User).(interface{ redact() map[string]any }); ok {
			m["user"] = r.redact()
		} else {
			m["user"] = json.RawMessage(protojson.Format(x.User))
		}
	}
	if x.BillingAddress != nil {
		if r, ok := any(x.BillingAddress).(interface{ redact() map[string]any }); ok {
			m["billingAddress"] = r.redact()
		} else {
			m["billingAddress"] = json.RawMessage(protojson.Format(x.BillingAddress))
		}
	}
	if x.ShippingAddress != nil {
		if r, ok := any(x.ShippingAddress).(interface{ redact() map[string]any }); ok {
			m["shippingAddress"] = r.redact()
		} else {
			m["shippingAddress"] = json.RawMessage(protojson.Format(x.ShippingAddress))
		}
	}
	return m
}

// Redact returns a redacted JSON string representation of Account.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *Account) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *Department) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["name"] = x.Name
	m["budget"] = "[BUDGET]"
	if len(x.Accounts) > 0 {
		items := make([]any, len(x.Accounts))
		for i, item := range x.Accounts {
			if item != nil {
				if r, ok := any(item).(interface{ redact() map[string]any }); ok {
					items[i] = r.redact()
				} else {
					items[i] = json.RawMessage(protojson.Format(item))
				}
			}
		}
		m["accounts"] = items
	}
	if x.Address != nil {
		if r, ok := any(x.Address).(interface{ redact() map[string]any }); ok {
			m["address"] = r.redact()
		} else {
			m["address"] = json.RawMessage(protojson.Format(x.Address))
		}
	}
	return m
}

// Redact returns a redacted JSON string representation of Department.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *Department) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *Organization) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["name"] = x.Name
	m["taxId"] = "[TAX_ID]"
	if len(x.Departments) > 0 {
		items := make([]any, len(x.Departments))
		for i, item := range x.Departments {
			if item != nil {
				if r, ok := any(item).(interface{ redact() map[string]any }); ok {
					items[i] = r.redact()
				} else {
					items[i] = json.RawMessage(protojson.Format(item))
				}
			}
		}
		m["departments"] = items
	}
	if x.Headquarters != nil {
		if r, ok := any(x.Headquarters).(interface{ redact() map[string]any }); ok {
			m["headquarters"] = r.redact()
		} else {
			m["headquarters"] = json.RawMessage(protojson.Format(x.Headquarters))
		}
	}
	return m
}

// Redact returns a redacted JSON string representation of Organization.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *Organization) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *Event) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["id"] = x.Id
	m["name"] = x.Name
	m["apiKey"] = "*"
	if x.CreatedAt != nil {
		if r, ok := any(x.CreatedAt).(interface{ redact() map[string]any }); ok {
			m["createdAt"] = r.redact()
		} else {
			m["createdAt"] = json.RawMessage(protojson.Format(x.CreatedAt))
		}
	}
	if x.UpdatedAt != nil {
		if r, ok := any(x.UpdatedAt).(interface{ redact() map[string]any }); ok {
			m["updatedAt"] = r.redact()
		} else {
			m["updatedAt"] = json.RawMessage(protojson.Format(x.UpdatedAt))
		}
	}
	m["secretTime"] = nil
	return m
}

// Redact returns a redacted JSON string representation of Event.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *Event) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *Task) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["id"] = x.Id
	m["name"] = x.Name
	if x.Timeout != nil {
		if r, ok := any(x.Timeout).(interface{ redact() map[string]any }); ok {
			m["timeout"] = r.redact()
		} else {
			m["timeout"] = json.RawMessage(protojson.Format(x.Timeout))
		}
	}
	m["secretDuration"] = nil
	return m
}

// Redact returns a redacted JSON string representation of Task.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *Task) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *WrapperTypes) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	if x.StringVal != nil {
		if r, ok := any(x.StringVal).(interface{ redact() map[string]any }); ok {
			m["stringVal"] = r.redact()
		} else {
			m["stringVal"] = json.RawMessage(protojson.Format(x.StringVal))
		}
	}
	if x.Int32Val != nil {
		if r, ok := any(x.Int32Val).(interface{ redact() map[string]any }); ok {
			m["int32Val"] = r.redact()
		} else {
			m["int32Val"] = json.RawMessage(protojson.Format(x.Int32Val))
		}
	}
	if x.Int64Val != nil {
		if r, ok := any(x.Int64Val).(interface{ redact() map[string]any }); ok {
			m["int64Val"] = r.redact()
		} else {
			m["int64Val"] = json.RawMessage(protojson.Format(x.Int64Val))
		}
	}
	if x.FloatVal != nil {
		if r, ok := any(x.FloatVal).(interface{ redact() map[string]any }); ok {
			m["floatVal"] = r.redact()
		} else {
			m["floatVal"] = json.RawMessage(protojson.Format(x.FloatVal))
		}
	}
	if x.DoubleVal != nil {
		if r, ok := any(x.DoubleVal).(interface{ redact() map[string]any }); ok {
			m["doubleVal"] = r.redact()
		} else {
			m["doubleVal"] = json.RawMessage(protojson.Format(x.DoubleVal))
		}
	}
	if x.BoolVal != nil {
		if r, ok := any(x.BoolVal).(interface{ redact() map[string]any }); ok {
			m["boolVal"] = r.redact()
		} else {
			m["boolVal"] = json.RawMessage(protojson.Format(x.BoolVal))
		}
	}
	if x.BytesVal != nil {
		if r, ok := any(x.BytesVal).(interface{ redact() map[string]any }); ok {
			m["bytesVal"] = r.redact()
		} else {
			m["bytesVal"] = json.RawMessage(protojson.Format(x.BytesVal))
		}
	}
	if x.Uint32Val != nil {
		if r, ok := any(x.Uint32Val).(interface{ redact() map[string]any }); ok {
			m["uint32Val"] = r.redact()
		} else {
			m["uint32Val"] = json.RawMessage(protojson.Format(x.Uint32Val))
		}
	}
	if x.Uint64Val != nil {
		if r, ok := any(x.Uint64Val).(interface{ redact() map[string]any }); ok {
			m["uint64Val"] = r.redact()
		} else {
			m["uint64Val"] = json.RawMessage(protojson.Format(x.Uint64Val))
		}
	}
	m["secretString"] = nil
	m["secretInt"] = nil
	return m
}

// Redact returns a redacted JSON string representation of WrapperTypes.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *WrapperTypes) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *AnyAndStruct) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["id"] = x.Id
	if x.Payload != nil {
		if r, ok := any(x.Payload).(interface{ redact() map[string]any }); ok {
			m["payload"] = r.redact()
		} else {
			m["payload"] = json.RawMessage(protojson.Format(x.Payload))
		}
	}
	m["secretPayload"] = nil
	if x.Metadata != nil {
		if r, ok := any(x.Metadata).(interface{ redact() map[string]any }); ok {
			m["metadata"] = r.redact()
		} else {
			m["metadata"] = json.RawMessage(protojson.Format(x.Metadata))
		}
	}
	m["secretMetadata"] = nil
	if x.Value != nil {
		if r, ok := any(x.Value).(interface{ redact() map[string]any }); ok {
			m["value"] = r.redact()
		} else {
			m["value"] = json.RawMessage(protojson.Format(x.Value))
		}
	}
	if x.ListValue != nil {
		if r, ok := any(x.ListValue).(interface{ redact() map[string]any }); ok {
			m["listValue"] = r.redact()
		} else {
			m["listValue"] = json.RawMessage(protojson.Format(x.ListValue))
		}
	}
	return m
}

// Redact returns a redacted JSON string representation of AnyAndStruct.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *AnyAndStruct) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *AllScalarTypes) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["doubleVal"] = x.DoubleVal
	m["floatVal"] = x.FloatVal
	m["redactDouble"] = float64(0)
	m["redactFloat"] = float64(0)
	m["int32Val"] = x.Int32Val
	m["int64Val"] = x.Int64Val
	m["redactInt32"] = int64(0)
	m["redactInt64"] = int64(0)
	m["uint32Val"] = x.Uint32Val
	m["uint64Val"] = x.Uint64Val
	m["redactUint32"] = int64(0)
	m["redactUint64"] = int64(0)
	m["sint32Val"] = x.Sint32Val
	m["sint64Val"] = x.Sint64Val
	m["redactSint32"] = int64(0)
	m["redactSint64"] = int64(0)
	m["fixed32Val"] = x.Fixed32Val
	m["fixed64Val"] = x.Fixed64Val
	m["redactFixed32"] = int64(0)
	m["redactFixed64"] = int64(0)
	m["sfixed32Val"] = x.Sfixed32Val
	m["sfixed64Val"] = x.Sfixed64Val
	m["redactSfixed32"] = int64(0)
	m["redactSfixed64"] = int64(0)
	m["boolVal"] = x.BoolVal
	m["redactBool"] = false
	m["stringVal"] = x.StringVal
	m["redactString"] = "*"
	m["redactStringCustom"] = "[CUSTOM]"
	m["bytesVal"] = x.BytesVal
	m["redactBytes"] = ""
	return m
}

// Redact returns a redacted JSON string representation of AllScalarTypes.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *AllScalarTypes) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *EnumTypes) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["status"] = x.Status
	m["priority"] = x.Priority
	m["redactStatus"] = int32(0)
	m["redactPriority"] = int32(0)
	return m
}

// Redact returns a redacted JSON string representation of EnumTypes.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *EnumTypes) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *RepeatedScalars) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	if len(x.DoubleVals) > 0 {
		m["doubleVals"] = x.DoubleVals
	}
	if len(x.FloatVals) > 0 {
		m["floatVals"] = x.FloatVals
	}
	if len(x.Int32Vals) > 0 {
		m["int32Vals"] = x.Int32Vals
	}
	if len(x.Int64Vals) > 0 {
		m["int64Vals"] = x.Int64Vals
	}
	if len(x.Uint32Vals) > 0 {
		m["uint32Vals"] = x.Uint32Vals
	}
	if len(x.Uint64Vals) > 0 {
		m["uint64Vals"] = x.Uint64Vals
	}
	if len(x.Sint32Vals) > 0 {
		m["sint32Vals"] = x.Sint32Vals
	}
	if len(x.Sint64Vals) > 0 {
		m["sint64Vals"] = x.Sint64Vals
	}
	if len(x.Fixed32Vals) > 0 {
		m["fixed32Vals"] = x.Fixed32Vals
	}
	if len(x.Fixed64Vals) > 0 {
		m["fixed64Vals"] = x.Fixed64Vals
	}
	if len(x.Sfixed32Vals) > 0 {
		m["sfixed32Vals"] = x.Sfixed32Vals
	}
	if len(x.Sfixed64Vals) > 0 {
		m["sfixed64Vals"] = x.Sfixed64Vals
	}
	if len(x.BoolVals) > 0 {
		m["boolVals"] = x.BoolVals
	}
	if len(x.StringVals) > 0 {
		m["stringVals"] = x.StringVals
	}
	if len(x.BytesVals) > 0 {
		m["bytesVals"] = x.BytesVals
	}
	m["redactDoubleVals"] = []any{}
	m["redactFloatVals"] = []any{}
	m["redactInt32Vals"] = []any{}
	m["redactInt64Vals"] = []any{}
	m["redactBoolVals"] = []any{}
	m["redactStringVals"] = []any{}
	m["redactBytesVals"] = []any{}
	return m
}

// Redact returns a redacted JSON string representation of RepeatedScalars.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *RepeatedScalars) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *RepeatedEnums) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	if len(x.Statuses) > 0 {
		m["statuses"] = x.Statuses
	}
	if len(x.Priorities) > 0 {
		m["priorities"] = x.Priorities
	}
	m["redactStatuses"] = []any{}
	return m
}

// Redact returns a redacted JSON string representation of RepeatedEnums.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *RepeatedEnums) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *RepeatedMessages) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	if len(x.Users) > 0 {
		items := make([]any, len(x.Users))
		for i, item := range x.Users {
			if item != nil {
				if r, ok := any(item).(interface{ redact() map[string]any }); ok {
					items[i] = r.redact()
				} else {
					items[i] = json.RawMessage(protojson.Format(item))
				}
			}
		}
		m["users"] = items
	}
	if len(x.Addresses) > 0 {
		items := make([]any, len(x.Addresses))
		for i, item := range x.Addresses {
			if item != nil {
				if r, ok := any(item).(interface{ redact() map[string]any }); ok {
					items[i] = r.redact()
				} else {
					items[i] = json.RawMessage(protojson.Format(item))
				}
			}
		}
		m["addresses"] = items
	}
	m["redactUsers"] = []any{}
	if len(x.Timestamps) > 0 {
		items := make([]any, len(x.Timestamps))
		for i, item := range x.Timestamps {
			if item != nil {
				if r, ok := any(item).(interface{ redact() map[string]any }); ok {
					items[i] = r.redact()
				} else {
					items[i] = json.RawMessage(protojson.Format(item))
				}
			}
		}
		m["timestamps"] = items
	}
	m["redactTimestamps"] = []any{}
	return m
}

// Redact returns a redacted JSON string representation of RepeatedMessages.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *RepeatedMessages) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *MapWithStringKey) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	if len(x.StringMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.StringMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["stringMap"] = mapVal
	}
	if len(x.Int32Map) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.Int32Map {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["int32Map"] = mapVal
	}
	if len(x.Int64Map) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.Int64Map {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["int64Map"] = mapVal
	}
	if len(x.DoubleMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.DoubleMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["doubleMap"] = mapVal
	}
	if len(x.BoolMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.BoolMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["boolMap"] = mapVal
	}
	if len(x.BytesMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.BytesMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["bytesMap"] = mapVal
	}
	if len(x.UserMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.UserMap {
			key := fmt.Sprintf("%v", k)
			if v != nil {
				if r, ok := any(v).(interface{ redact() map[string]any }); ok {
					mapVal[key] = r.redact()
				} else {
					mapVal[key] = json.RawMessage(protojson.Format(v))
				}
			}
		}
		m["userMap"] = mapVal
	}
	if len(x.AddressMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.AddressMap {
			key := fmt.Sprintf("%v", k)
			if v != nil {
				if r, ok := any(v).(interface{ redact() map[string]any }); ok {
					mapVal[key] = r.redact()
				} else {
					mapVal[key] = json.RawMessage(protojson.Format(v))
				}
			}
		}
		m["addressMap"] = mapVal
	}
	if len(x.StatusMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.StatusMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["statusMap"] = mapVal
	}
	m["redactStringMap"] = map[string]any{}
	m["redactInt64Map"] = map[string]any{}
	m["redactUserMap"] = map[string]any{}
	return m
}

// Redact returns a redacted JSON string representation of MapWithStringKey.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *MapWithStringKey) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *MapWithIntKey) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	if len(x.Int32KeyMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.Int32KeyMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["int32KeyMap"] = mapVal
	}
	if len(x.Int64KeyMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.Int64KeyMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["int64KeyMap"] = mapVal
	}
	if len(x.Uint32KeyMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.Uint32KeyMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["uint32KeyMap"] = mapVal
	}
	if len(x.Uint64KeyMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.Uint64KeyMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["uint64KeyMap"] = mapVal
	}
	if len(x.Sint32KeyMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.Sint32KeyMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["sint32KeyMap"] = mapVal
	}
	if len(x.Sint64KeyMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.Sint64KeyMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["sint64KeyMap"] = mapVal
	}
	if len(x.Fixed32KeyMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.Fixed32KeyMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["fixed32KeyMap"] = mapVal
	}
	if len(x.Fixed64KeyMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.Fixed64KeyMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["fixed64KeyMap"] = mapVal
	}
	if len(x.Sfixed32KeyMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.Sfixed32KeyMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["sfixed32KeyMap"] = mapVal
	}
	if len(x.Sfixed64KeyMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.Sfixed64KeyMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["sfixed64KeyMap"] = mapVal
	}
	m["redactInt32KeyMap"] = map[string]any{}
	m["redactInt64UserMap"] = map[string]any{}
	return m
}

// Redact returns a redacted JSON string representation of MapWithIntKey.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *MapWithIntKey) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *MapWithBoolKey) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	if len(x.BoolKeyMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.BoolKeyMap {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["boolKeyMap"] = mapVal
	}
	if len(x.BoolUserMap) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.BoolUserMap {
			key := fmt.Sprintf("%v", k)
			if v != nil {
				if r, ok := any(v).(interface{ redact() map[string]any }); ok {
					mapVal[key] = r.redact()
				} else {
					mapVal[key] = json.RawMessage(protojson.Format(v))
				}
			}
		}
		m["boolUserMap"] = mapVal
	}
	m["redactBoolKeyMap"] = map[string]any{}
	return m
}

// Redact returns a redacted JSON string representation of MapWithBoolKey.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *MapWithBoolKey) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *OneofWithRedact) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["id"] = x.Id
	if x.GetApiKey() != "" {
		m["apiKey"] = "*"
	}
	if x.GetToken() != "" {
		m["token"] = "[TOKEN]"
	}
	if x.GetSecret() != nil {
		m["secret"] = ""
	}
	m["description"] = x.GetDescription()
	m["count"] = x.GetCount()
	return m
}

// Redact returns a redacted JSON string representation of OneofWithRedact.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *OneofWithRedact) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *OneofWithMessage) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["id"] = x.Id
	if x.GetUser() != nil {
		if r, ok := any(x.GetUser()).(interface{ redact() map[string]any }); ok {
			m["user"] = r.redact()
		} else {
			m["user"] = json.RawMessage(protojson.Format(x.GetUser()))
		}
	}
	if x.GetAddress() != nil {
		if r, ok := any(x.GetAddress()).(interface{ redact() map[string]any }); ok {
			m["address"] = r.redact()
		} else {
			m["address"] = json.RawMessage(protojson.Format(x.GetAddress()))
		}
	}
	if x.GetAccount() != nil {
		if r, ok := any(x.GetAccount()).(interface{ redact() map[string]any }); ok {
			m["account"] = r.redact()
		} else {
			m["account"] = json.RawMessage(protojson.Format(x.GetAccount()))
		}
	}
	if x.GetSecretUser() != nil {
		m["secretUser"] = nil
	}
	if x.GetSecretString() != "" {
		m["secretString"] = "*"
	}
	return m
}

// Redact returns a redacted JSON string representation of OneofWithMessage.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *OneofWithMessage) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *ComplexMessage) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["id"] = x.Id
	m["name"] = x.Name
	m["secret"] = "*"
	m["count"] = x.Count
	m["score"] = x.Score
	m["active"] = x.Active
	m["redactCount"] = int64(0)
	m["status"] = x.Status
	m["redactStatus"] = int32(0)
	if x.Owner != nil {
		if r, ok := any(x.Owner).(interface{ redact() map[string]any }); ok {
			m["owner"] = r.redact()
		} else {
			m["owner"] = json.RawMessage(protojson.Format(x.Owner))
		}
	}
	if x.Location != nil {
		if r, ok := any(x.Location).(interface{ redact() map[string]any }); ok {
			m["location"] = r.redact()
		} else {
			m["location"] = json.RawMessage(protojson.Format(x.Location))
		}
	}
	m["redactOwner"] = nil
	if x.CreatedAt != nil {
		if r, ok := any(x.CreatedAt).(interface{ redact() map[string]any }); ok {
			m["createdAt"] = r.redact()
		} else {
			m["createdAt"] = json.RawMessage(protojson.Format(x.CreatedAt))
		}
	}
	if x.Timeout != nil {
		if r, ok := any(x.Timeout).(interface{ redact() map[string]any }); ok {
			m["timeout"] = r.redact()
		} else {
			m["timeout"] = json.RawMessage(protojson.Format(x.Timeout))
		}
	}
	m["redactTime"] = nil
	if len(x.Tags) > 0 {
		m["tags"] = x.Tags
	}
	if len(x.Members) > 0 {
		items := make([]any, len(x.Members))
		for i, item := range x.Members {
			if item != nil {
				if r, ok := any(item).(interface{ redact() map[string]any }); ok {
					items[i] = r.redact()
				} else {
					items[i] = json.RawMessage(protojson.Format(item))
				}
			}
		}
		m["members"] = items
	}
	m["redactTags"] = []any{}
	m["redactMembers"] = []any{}
	if len(x.Labels) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.Labels {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["labels"] = mapVal
	}
	if len(x.Assignees) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.Assignees {
			key := fmt.Sprintf("%v", k)
			if v != nil {
				if r, ok := any(v).(interface{ redact() map[string]any }); ok {
					mapVal[key] = r.redact()
				} else {
					mapVal[key] = json.RawMessage(protojson.Format(v))
				}
			}
		}
		m["assignees"] = mapVal
	}
	m["redactLabels"] = map[string]any{}
	m["redactAssignees"] = map[string]any{}
	if len(x.IndexedData) > 0 {
		mapVal := make(map[string]any)
		for k, v := range x.IndexedData {
			key := fmt.Sprintf("%v", k)
			mapVal[key] = v
		}
		m["indexedData"] = mapVal
	}
	m["note"] = x.GetNote()
	m["priorityValue"] = x.GetPriorityValue()
	if x.GetReviewer() != nil {
		if r, ok := any(x.GetReviewer()).(interface{ redact() map[string]any }); ok {
			m["reviewer"] = r.redact()
		} else {
			m["reviewer"] = json.RawMessage(protojson.Format(x.GetReviewer()))
		}
	}
	if x.GetSecretNote() != "" {
		m["secretNote"] = "*"
	}
	if x.GetSecretPriority() != 0 {
		m["secretPriority"] = int64(0)
	}
	return m
}

// Redact returns a redacted JSON string representation of ComplexMessage.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *ComplexMessage) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *MessageWithOnlyRedact) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["password"] = "*"
	m["token"] = "*"
	return m
}

// Redact returns a redacted JSON string representation of MessageWithOnlyRedact.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *MessageWithOnlyRedact) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *MessageWithNoRedact) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["id"] = x.Id
	m["name"] = x.Name
	if x.User != nil {
		if r, ok := any(x.User).(interface{ redact() map[string]any }); ok {
			m["user"] = r.redact()
		} else {
			m["user"] = json.RawMessage(protojson.Format(x.User))
		}
	}
	return m
}

// Redact returns a redacted JSON string representation of MessageWithNoRedact.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *MessageWithNoRedact) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *Level4) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["secret"] = "*"
	return m
}

// Redact returns a redacted JSON string representation of Level4.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *Level4) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *Level3) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["name"] = x.Name
	if x.Level4 != nil {
		if r, ok := any(x.Level4).(interface{ redact() map[string]any }); ok {
			m["level4"] = r.redact()
		} else {
			m["level4"] = json.RawMessage(protojson.Format(x.Level4))
		}
	}
	return m
}

// Redact returns a redacted JSON string representation of Level3.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *Level3) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *Level2) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["name"] = x.Name
	if x.Level3 != nil {
		if r, ok := any(x.Level3).(interface{ redact() map[string]any }); ok {
			m["level3"] = r.redact()
		} else {
			m["level3"] = json.RawMessage(protojson.Format(x.Level3))
		}
	}
	return m
}

// Redact returns a redacted JSON string representation of Level2.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *Level2) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *Level1) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["name"] = x.Name
	if x.Level2 != nil {
		if r, ok := any(x.Level2).(interface{ redact() map[string]any }); ok {
			m["level2"] = r.redact()
		} else {
			m["level2"] = json.RawMessage(protojson.Format(x.Level2))
		}
	}
	return m
}

// Redact returns a redacted JSON string representation of Level1.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *Level1) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *SpecialCharacters) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["normal"] = x.Normal
	m["withQuotes"] = "\"quoted\""
	m["withBackslash"] = "back\\slash"
	m["withNewline"] = "line1\\nline2"
	m["unicode"] = "Hello World"
	m["emoji"] = "[LOCKED]"
	return m
}

// Redact returns a redacted JSON string representation of SpecialCharacters.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *SpecialCharacters) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

// redact returns a map representation with sensitive fields masked.
// This is used internally for recursive redaction without JSON escaping issues.
func (x *CustomMaskTypes) redact() map[string]any {
	if x == nil {
		return nil
	}
	m := make(map[string]any)
	m["password"] = "[PASSWORD]"
	m["secretInt32"] = int64(-1)
	m["secretInt64"] = int64(-999)
	m["secretUint32"] = int64(9999)
	m["secretUint64"] = int64(8888)
	m["secretSint32"] = int64(-100)
	m["secretSint64"] = int64(-200)
	m["secretFixed32"] = int64(1111)
	m["secretFixed64"] = int64(2222)
	m["secretSfixed32"] = int64(-333)
	m["secretSfixed64"] = int64(-444)
	m["secretFloat"] = float64(-1.5)
	m["secretDouble"] = float64(-999.99)
	m["secretBool"] = true
	m["secretBytes"] = "[BINARY]"
	m["secretStatus"] = int32(99)
	m["secretPriority"] = int32(1)
	m["publicString"] = x.PublicString
	m["publicInt64"] = x.PublicInt64
	m["publicDouble"] = x.PublicDouble
	m["publicBool"] = x.PublicBool
	m["publicBytes"] = x.PublicBytes
	m["publicStatus"] = x.PublicStatus
	return m
}

// Redact returns a redacted JSON string representation of CustomMaskTypes.
// Sensitive fields are masked to prevent accidental logging of sensitive data.
// This method implements the Redacter interface for Kratos logging middleware.
func (x *CustomMaskTypes) Redact() string {
	if x == nil {
		return "{}"
	}
	b, _ := json.Marshal(x.redact())
	return string(b)
}

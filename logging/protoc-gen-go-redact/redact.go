// Package main implements protoc-gen-go-redact, a protoc plugin that generates
// Redact() methods for protobuf messages containing sensitive fields.
//
// The plugin scans proto files for fields annotated with the (kit.redact.v1.redact) option,
// and generates corresponding Go code that masks these fields when logging or serializing.
//
// Usage:
//
//	protoc --go-redact_out=. --go-redact_opt=paths=source_relative your.proto
//
// The generated code provides:
//   - redact() method: returns a map[string]any with sensitive fields masked (internal use)
//   - Redact() method: returns a JSON string with sensitive fields masked (public API)
package main

import (
	"fmt"

	redact "github.com/crypto-zero/go-kit/proto/kit/redact/v1"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

// defaultStringMask is the default mask value for string fields.
// String fields need an explicit default because "*" differs from Go's zero value ("").
// Other scalar types (int, float, bool, bytes, enum) use Go zero values as defaults.
const defaultStringMask = "*"

// integerKinds maps all protobuf integer types for O(1) type checking.
// This includes signed, unsigned, fixed-width, and variable-width integer types.
var integerKinds = map[protoreflect.Kind]bool{
	protoreflect.Int32Kind:    true, // int32
	protoreflect.Int64Kind:    true, // int64
	protoreflect.Uint32Kind:   true, // uint32
	protoreflect.Uint64Kind:   true, // uint64
	protoreflect.Sint32Kind:   true, // sint32 (ZigZag encoded)
	protoreflect.Sint64Kind:   true, // sint64 (ZigZag encoded)
	protoreflect.Fixed32Kind:  true, // fixed32 (always 4 bytes)
	protoreflect.Fixed64Kind:  true, // fixed64 (always 8 bytes)
	protoreflect.Sfixed32Kind: true, // sfixed32 (signed, always 4 bytes)
	protoreflect.Sfixed64Kind: true, // sfixed64 (signed, always 8 bytes)
}

// floatKinds maps protobuf floating-point types for O(1) type checking.
var floatKinds = map[protoreflect.Kind]bool{
	protoreflect.FloatKind:  true, // float (32-bit)
	protoreflect.DoubleKind: true, // double (64-bit)
}

// generateFile generates a _redact.pb.go file containing Redact() method implementations.
//
// The generation process follows three phases:
//  1. Direct collection: Find messages with fields explicitly marked for redaction
//  2. Propagation: Mark parent messages that contain redactable child messages
//  3. Code generation: Build descriptors and generate Go code
//
// Returns nil if no messages require redaction (no file will be generated).
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	// Skip files with no messages
	if len(file.Messages) == 0 {
		return nil
	}

	// Phase 1: Collect messages that directly have redact fields.
	// These are messages where at least one field has the redact option set.
	messagesNeedRedact := make(map[string]bool)
	collectMessagesWithDirectRedact(file.Messages, messagesNeedRedact)

	// Phase 2: Propagate redact requirement up the message hierarchy.
	// If message A contains a field of type B, and B needs redaction,
	// then A also needs a Redact() method to properly redact the nested B.
	propagateRedactRequirement(file.Messages, messagesNeedRedact)

	// Phase 3: Build message descriptors for template-based code generation.
	// Each descriptor contains all information needed to generate the Redact() method.
	var messagesWithRedact []*messageDesc
	collectMessagesForGeneration(file.Messages, messagesNeedRedact, &messagesWithRedact)

	// Skip file generation if no messages need redaction
	if len(messagesWithRedact) == 0 {
		return nil
	}

	return writeGeneratedFile(gen, file, messagesWithRedact)
}

// writeGeneratedFile creates the generated file with imports and message methods.
// It writes the file header, package declaration, required imports, and
// generates redact()/Redact() methods for each message using templates.
func writeGeneratedFile(gen *protogen.Plugin, file *protogen.File, messages []*messageDesc) *protogen.GeneratedFile {
	// Create output file: {original}_redact.pb.go
	filename := file.GeneratedFilenamePrefix + "_redact.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// Write standard protoc-gen file header with version information
	g.P("// Code generated by protoc-gen-go-redact. DO NOT EDIT.")
	g.P("// versions:")
	g.P(fmt.Sprintf("// - protoc-gen-go-redact %s", release))
	g.P("// - protoc             ", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Write imports - only include fmt if needed for map key formatting
	g.P("import (")
	g.P(`	"encoding/json"`) // Required for JSON marshaling in Redact()
	if needsFmtPackage(messages) {
		g.P(`	"fmt"`) // Required for fmt.Sprintf("%v", key) in map iteration
	}
	g.P()
	g.P(`	"google.golang.org/protobuf/encoding/protojson"`) // Required for formatting proto messages
	g.P(")")
	g.P()

	// Generate redact() and Redact() methods for each message using templates
	for _, md := range messages {
		g.P(md.execute())
	}

	return g
}

// needsFmtPackage checks if the generated code needs to import the "fmt" package.
//
// The fmt package is only needed when iterating over non-redacted map fields,
// because map keys need to be converted to strings using fmt.Sprintf("%v", key).
// Redacted maps are replaced with empty maps, so they don't need key conversion.
func needsFmtPackage(messages []*messageDesc) bool {
	for _, md := range messages {
		for _, fd := range md.Fields {
			if fd.IsMap && !fd.Redact {
				return true
			}
		}
	}
	return false
}

// collectMessagesWithDirectRedact recursively scans all messages (including nested ones)
// and marks those that have at least one field with the redact option enabled.
//
// Example: If User.password has [(kit.redact.v1.redact).redact = true],
// then "example.User" will be added to the result map.
func collectMessagesWithDirectRedact(messages []*protogen.Message, result map[string]bool) {
	for _, msg := range messages {
		if hasDirectRedactField(msg) {
			result[string(msg.Desc.FullName())] = true
		}
		// Recursively process nested message definitions
		collectMessagesWithDirectRedact(msg.Messages, result)
	}
}

// hasDirectRedactField checks if a message has any field directly marked with redact option.
// Returns true if at least one field has redact = true in its options.
func hasDirectRedactField(msg *protogen.Message) bool {
	for _, field := range msg.Fields {
		if opts := getRedactOptions(field); opts != nil && opts.GetRedact() {
			return true
		}
	}
	return false
}

// getRedactOptions extracts the RedactOptions proto extension from a field.
//
// Fields can be annotated in proto files like:
//
//	string password = 1 [(kit.redact.v1.redact) = {redact: true, string_mask: "[HIDDEN]"}];
//
// Returns nil if the field has no redact option.
func getRedactOptions(field *protogen.Field) *redact.RedactOptions {
	opts := field.Desc.Options().(*descriptorpb.FieldOptions)
	if opts == nil || !proto.HasExtension(opts, redact.E_Redact) {
		return nil
	}
	return proto.GetExtension(opts, redact.E_Redact).(*redact.RedactOptions)
}

// propagateRedactRequirement propagates the redact requirement up the message hierarchy.
//
// This implements a fixed-point algorithm: if message A contains a field of type B,
// and B needs redaction, then A also needs a Redact() method to properly handle
// the nested message. The algorithm iterates until no new messages are marked.
//
// Example:
//
//	message Account {
//	    User user = 1;  // User has redacted fields
//	}
//
// Account will be marked as needing redaction because it contains User.
func propagateRedactRequirement(messages []*protogen.Message, needsRedact map[string]bool) {
	// Fixed-point iteration: keep propagating until no changes occur
	for changed := true; changed; {
		changed = false
		propagateForMessages(messages, needsRedact, &changed)
	}
}

// propagateForMessages is the recursive helper for propagateRedactRequirement.
// It checks each message's fields and marks the message if any field references
// a message that needs redaction.
func propagateForMessages(messages []*protogen.Message, needsRedact map[string]bool, changed *bool) {
	for _, msg := range messages {
		msgName := string(msg.Desc.FullName())

		// Skip if already marked; check all message-type fields
		if !needsRedact[msgName] {
			for _, field := range msg.Fields {
				// Only message-type fields can propagate redact requirements
				if field.Desc.Kind() == protoreflect.MessageKind {
					referencedMsg := string(field.Desc.Message().FullName())
					if needsRedact[referencedMsg] {
						needsRedact[msgName] = true
						*changed = true // Signal that we made progress
						break
					}
				}
			}
		}

		// Recursively process nested message definitions
		propagateForMessages(msg.Messages, needsRedact, changed)
	}
}

// collectMessagesForGeneration builds messageDesc structs for all messages that need
// Redact() method generation. These descriptors are then passed to the template engine.
//
// Note: Map entry types (e.g., MapField_Entry) are skipped because they are internal
// protobuf implementation details and shouldn't have user-facing Redact() methods.
func collectMessagesForGeneration(messages []*protogen.Message, needsRedact map[string]bool, result *[]*messageDesc) {
	for _, msg := range messages {
		// Skip protobuf's internal map entry types (e.g., "MyMessage.FieldNameEntry")
		// These are auto-generated wrapper messages for map<K,V> fields
		if msg.Desc.IsMapEntry() {
			continue
		}

		// Build descriptor if this message needs redaction
		if needsRedact[string(msg.Desc.FullName())] {
			*result = append(*result, buildMessageDesc(msg))
		}

		// Recursively process nested message definitions
		collectMessagesForGeneration(msg.Messages, needsRedact, result)
	}
}

// buildMessageDesc creates a messageDesc from a protogen.Message for template execution.
//
// The descriptor captures all information needed by the template to generate code:
//   - Message name (for method receiver)
//   - Field metadata (type flags, JSON names, redact options)
//   - Custom mask values for each redacted field
//
// Field type detection follows this priority to handle overlapping cases:
//   - Map fields are checked first (map<K,V> is technically a repeated message)
//   - Repeated fields exclude maps
//   - Message fields exclude maps
//   - Oneof fields need special getter-based access in generated code
func buildMessageDesc(msg *protogen.Message) *messageDesc {
	fields := make([]*fieldDesc, 0, len(msg.Fields))

	for _, field := range msg.Fields {
		kind := field.Desc.Kind()
		isMap := field.Desc.IsMap()

		// Build field descriptor with type flags
		fd := &fieldDesc{
			GoName:     field.GoName,                                          // Go struct field name (PascalCase)
			JSONName:   string(field.Desc.JSONName()),                         // JSON/proto field name (camelCase)
			IsMessage:  kind == protoreflect.MessageKind && !isMap,            // Nested message (not map)
			IsRepeated: field.Desc.IsList() && !isMap,                         // Repeated field (not map)
			IsInteger:  integerKinds[kind],                                    // Any integer type
			IsFloat:    floatKinds[kind],                                      // float or double
			IsBool:     kind == protoreflect.BoolKind,                         // bool
			IsBytes:    kind == protoreflect.BytesKind,                        // bytes
			IsEnum:     kind == protoreflect.EnumKind,                         // enum
			IsMap:      isMap,                                                 // map<K,V>
			IsOneof:    field.Oneof != nil && !field.Oneof.Desc.IsSynthetic(), // Part of a oneof group
			StringMask: defaultStringMask,                                     // Default mask; others use Go zero values
		}

		// For map fields, check if the value type is a message (needs recursive redaction)
		if isMap {
			mapValue := field.Desc.MapValue()
			fd.MapValueIsMessage = mapValue.Kind() == protoreflect.MessageKind
		}

		// Apply redact options if this field is marked for redaction
		if opts := getRedactOptions(field); opts != nil && opts.GetRedact() {
			fd.Redact = true
			// Parse custom mask value from the oneof in RedactOptions
			// Each type has its own mask field to preserve type safety
			switch v := opts.GetMaskValue().(type) {
			case *redact.RedactOptions_StringMask:
				fd.StringMask = v.StringMask // e.g., "[HIDDEN]", "***"
			case *redact.RedactOptions_IntMask:
				fd.IntMask = v.IntMask // e.g., -1, 0, 9999
			case *redact.RedactOptions_DoubleMask:
				fd.DoubleMask = v.DoubleMask // e.g., 0.0, -1.0
			case *redact.RedactOptions_BoolMask:
				fd.BoolMask = v.BoolMask // true or false
			case *redact.RedactOptions_BytesMask:
				fd.BytesMask = v.BytesMask // e.g., "[REDACTED]"
			case *redact.RedactOptions_EnumMask:
				fd.EnumMask = v.EnumMask // enum value as int32
			}
		}

		fields = append(fields, fd)
	}

	return &messageDesc{
		Name:   msg.GoIdent.GoName, // Go type name for the message
		Fields: fields,
	}
}

// protocVersion extracts the protoc compiler version from the plugin request.
// This is included in the generated file header for debugging and compatibility tracking.
// Returns "(unknown)" if version information is not available.
func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	// Format: vMAJOR.MINOR.PATCH[-SUFFIX]
	// Example: v3.21.12, v4.25.0-rc1
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

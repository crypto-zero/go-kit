// Package main implements protoc-gen-go-redact, a protoc plugin that generates
// Redact() methods for protobuf messages containing sensitive fields.
//
// The plugin scans proto files for fields annotated with the (kit.redact.v1.redact) option,
// and generates corresponding Go code that masks these fields when logging or serializing.
//
// Usage:
//
//	protoc --go-redact_out=. --go-redact_opt=paths=source_relative your.proto
//
// The generated code provides:
//   - redact() method: returns a map[string]any with sensitive fields masked (internal use)
//   - Redact() method: returns a JSON string with sensitive fields masked (public API)
package main

import (
	"fmt"
	"strconv"

	"github.com/crypto-zero/go-kit/proto/kit/redact/v1"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

var (
	fmtPackage       = protogen.GoImportPath("fmt")
	jsonPackage      = protogen.GoImportPath("encoding/json")
	protojsonPackage = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
)

// defaultStringMask is the default mask value for string fields.
// String fields need an explicit default because "*" differs from Go's zero value ("").
// Other scalar types (int, float, bool, bytes, enum) use Go zero values as defaults.
const defaultStringMask = "*"

// integerKinds maps all protobuf integer types for O(1) type checking.
// This includes signed, unsigned, fixed-width, and variable-width integer types.
var integerKinds = map[protoreflect.Kind]bool{
	protoreflect.Int32Kind:    true, // int32
	protoreflect.Int64Kind:    true, // int64
	protoreflect.Uint32Kind:   true, // uint32
	protoreflect.Uint64Kind:   true, // uint64
	protoreflect.Sint32Kind:   true, // sint32 (ZigZag encoded)
	protoreflect.Sint64Kind:   true, // sint64 (ZigZag encoded)
	protoreflect.Fixed32Kind:  true, // fixed32 (always 4 bytes)
	protoreflect.Fixed64Kind:  true, // fixed64 (always 8 bytes)
	protoreflect.Sfixed32Kind: true, // sfixed32 (signed, always 4 bytes)
	protoreflect.Sfixed64Kind: true, // sfixed64 (signed, always 8 bytes)
}

// floatKinds maps protobuf floating-point types for O(1) type checking.
var floatKinds = map[protoreflect.Kind]bool{
	protoreflect.FloatKind:  true, // float (32-bit)
	protoreflect.DoubleKind: true, // double (64-bit)
}

// generateFile generates a _redact.pb.go file containing Redact() method implementations.
//
// The generation process follows three phases:
//  1. Direct collection: Find messages with fields explicitly marked for redaction
//  2. Propagation: Mark parent messages that contain redactable child messages
//  3. Code generation: Build descriptors and generate Go code
//
// Returns nil if no messages require redaction (no file will be generated).
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	// Skip files with no messages
	if len(file.Messages) == 0 {
		return nil
	}

	// Phase 1: Collect messages that directly have redact fields.
	// These are messages where at least one field has the redact option set.
	messagesNeedRedact := make(map[string]bool)
	collectMessagesWithDirectRedact(file.Messages, messagesNeedRedact)

	// Phase 2: Propagate redact requirement up the message hierarchy.
	// If message A contains a field of type B, and B needs redaction,
	// then A also needs a Redact() method to properly redact the nested B.
	propagateRedactRequirement(file.Messages, messagesNeedRedact)

	// Phase 3: Build message descriptors for template-based code generation.
	// Each descriptor contains all information needed to generate the Redact() method.
	var messagesWithRedact []*messageDesc
	collectMessagesForGeneration(file.Messages, messagesNeedRedact, &messagesWithRedact)

	// Skip file generation if no messages need redaction
	if len(messagesWithRedact) == 0 {
		return nil
	}

	return writeGeneratedFile(gen, file, messagesWithRedact)
}

// writeGeneratedFile creates the generated file with imports and message methods.
// It writes the file header, package declaration, required imports, and
// generates redact()/Redact() methods for each message using templates.
func writeGeneratedFile(gen *protogen.Plugin, file *protogen.File, messages []*messageDesc) *protogen.GeneratedFile {
	// Create output file: {original}_redact.pb.go
	filename := file.GeneratedFilenamePrefix + "_redact.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// Write standard protoc-gen file header with version information
	g.P("// Code generated by protoc-gen-go-redact. DO NOT EDIT.")
	g.P("// versions:")
	g.P(fmt.Sprintf("// - protoc-gen-go-redact %s", release))
	g.P("// - protoc             ", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Generate redact() and Redact() methods for each message using g.P
	for _, md := range messages {
		genMessage(g, md)
	}

	return g
}

// collectMessagesWithDirectRedact recursively scans all messages (including nested ones)
// and marks those that have at least one field with the redact option enabled.
//
// Example: If User.password has [(kit.redact.v1.redact).redact = true],
// then "example.User" will be added to the result map.
func collectMessagesWithDirectRedact(messages []*protogen.Message, result map[string]bool) {
	for _, msg := range messages {
		if hasDirectRedactField(msg) {
			result[string(msg.Desc.FullName())] = true
		}
		// Recursively process nested message definitions
		collectMessagesWithDirectRedact(msg.Messages, result)
	}
}

// hasDirectRedactField checks if a message has any field directly marked with redact option.
// Returns true if at least one field has redact = true in its options.
func hasDirectRedactField(msg *protogen.Message) bool {
	for _, field := range msg.Fields {
		if opts := getRedactOptions(field); opts != nil && opts.GetRedact() {
			return true
		}
	}
	return false
}

// getRedactOptions extracts the RedactOptions proto extension from a field.
//
// Fields can be annotated in proto files like:
//
//	string password = 1 [(kit.redact.v1.redact) = {redact: true, string_mask: "[HIDDEN]"}];
//
// Returns nil if the field has no redact option.
func getRedactOptions(field *protogen.Field) *redact.RedactOptions {
	opts := field.Desc.Options().(*descriptorpb.FieldOptions)
	if opts == nil || !proto.HasExtension(opts, redact.E_Redact) {
		return nil
	}
	return proto.GetExtension(opts, redact.E_Redact).(*redact.RedactOptions)
}

// propagateRedactRequirement propagates the redact requirement up the message hierarchy.
//
// This implements a fixed-point algorithm: if message A contains a field of type B,
// and B needs redaction, then A also needs a Redact() method to properly handle
// the nested message. The algorithm iterates until no new messages are marked.
//
// Example:
//
//	message Account {
//	    User user = 1;  // User has redacted fields
//	}
//
// Account will be marked as needing redaction because it contains User.
// propagateRedactRequirement propagates the redact requirement up the message hierarchy.
//
// This implements a standard BFS algorithm on the reverse dependency graph.
// Instead of repeatedly scanning all messages (O(N^2)), we:
// 1. Build a reverse graph where edges point from Child -> Parents
// 2. Start BFS from messages that already need redaction
// 3. Mark parents as needing redaction and add them to the queue
//
// Complexity: O(N + E) where N is number of messages and E is number of field references.
func propagateRedactRequirement(messages []*protogen.Message, needsRedact map[string]bool) {
	// 1. Build reverse dependency graph: Child -> [Parent1, Parent2, ...]
	// Map key: full name of the child message
	// Map value: list of full names of parent messages that contain this child
	parents := make(map[string][]string)

	// Visit all messages to build the graph
	// We need a helper to traverse nested messages
	var buildGraph func([]*protogen.Message)
	buildGraph = func(msgs []*protogen.Message) {
		for _, parent := range msgs {
			parentName := string(parent.Desc.FullName())

			// Check all fields of this parent
			for _, field := range parent.Fields {
				if field.Desc.Kind() == protoreflect.MessageKind {
					childName := string(field.Desc.Message().FullName())
					parents[childName] = append(parents[childName], parentName)
				}
			}

			// Recurse into nested messages
			buildGraph(parent.Messages)
		}
	}
	buildGraph(messages)

	// 2. Initialize worklist (queue) with messages that already need redaction
	var queue []string
	for msgName := range needsRedact {
		queue = append(queue, msgName)
	}

	// 3. Process queue (BFS)
	// We don't need a separate 'visited' set because 'needsRedact' acts as one.
	// If a message is in needsRedact, it has been visited/processed.
	for len(queue) > 0 {
		childName := queue[0]
		queue = queue[1:]

		// Find all parents that depend on this child
		for _, parentName := range parents[childName] {
			// If parent is not yet marked, mark it and add to queue
			if !needsRedact[parentName] {
				needsRedact[parentName] = true
				queue = append(queue, parentName)
			}
		}
	}
}

// collectMessagesForGeneration builds messageDesc structs for all messages that need
// Redact() method generation. These descriptors are then passed to the template engine.
//
// Note: Map entry types (e.g., MapField_Entry) are skipped because they are internal
// protobuf implementation details and shouldn't have user-facing Redact() methods.
func collectMessagesForGeneration(messages []*protogen.Message, needsRedact map[string]bool, result *[]*messageDesc) {
	for _, msg := range messages {
		// Skip protobuf's internal map entry types (e.g., "MyMessage.FieldNameEntry")
		// These are auto-generated wrapper messages for map<K,V> fields
		if msg.Desc.IsMapEntry() {
			continue
		}

		// Build descriptor if this message needs redaction
		if needsRedact[string(msg.Desc.FullName())] {
			*result = append(*result, buildMessageDesc(msg))
		}

		// Recursively process nested message definitions
		collectMessagesForGeneration(msg.Messages, needsRedact, result)
	}
}

// buildMessageDesc creates a messageDesc from a protogen.Message for template execution.
//
// The descriptor captures all information needed by the template to generate code:
//   - Message name (for method receiver)
//   - Field metadata (type flags, JSON names, redact options)
//   - Custom mask values for each redacted field
//
// Field type detection follows this priority to handle overlapping cases:
//   - Map fields are checked first (map<K,V> is technically a repeated message)
//   - Repeated fields exclude maps
//   - Message fields exclude maps
//   - Oneof fields need special getter-based access in generated code
func buildMessageDesc(msg *protogen.Message) *messageDesc {
	fields := make([]*fieldDesc, 0, len(msg.Fields))

	for _, field := range msg.Fields {
		kind := field.Desc.Kind()
		isMap := field.Desc.IsMap()

		// Build field descriptor with type flags
		fd := &fieldDesc{
			GoName:     field.GoName,                                          // Go struct field name (PascalCase)
			JSONName:   string(field.Desc.JSONName()),                         // JSON/proto field name (camelCase)
			IsMessage:  kind == protoreflect.MessageKind && !isMap,            // Nested message (not map)
			IsRepeated: field.Desc.IsList() && !isMap,                         // Repeated field (not map)
			IsInteger:  integerKinds[kind],                                    // Any integer type
			IsFloat:    floatKinds[kind],                                      // float or double
			IsBool:     kind == protoreflect.BoolKind,                         // bool
			IsBytes:    kind == protoreflect.BytesKind,                        // bytes
			IsEnum:     kind == protoreflect.EnumKind,                         // enum
			IsMap:      isMap,                                                 // map<K,V>
			IsOneof:    field.Oneof != nil && !field.Oneof.Desc.IsSynthetic(), // Part of a oneof group
			StringMask: defaultStringMask,                                     // Default mask; others use Go zero values
		}

		// For map fields, check if the value type is a message (needs recursive redaction)
		if isMap {
			mapValue := field.Desc.MapValue()
			fd.MapValueIsMessage = mapValue.Kind() == protoreflect.MessageKind
		}

		// Apply redact options if this field is marked for redaction
		if opts := getRedactOptions(field); opts != nil && opts.GetRedact() {
			fd.Redact = true
			// Parse custom mask value from the oneof in RedactOptions
			// Each type has its own mask field to preserve type safety
			switch v := opts.GetMaskValue().(type) {
			case *redact.RedactOptions_StringMask:
				fd.StringMask = v.StringMask // e.g., "[HIDDEN]", "***"
			case *redact.RedactOptions_IntMask:
				fd.IntMask = v.IntMask // e.g., -1, 0, 9999
			case *redact.RedactOptions_DoubleMask:
				fd.DoubleMask = v.DoubleMask // e.g., 0.0, -1.0
			case *redact.RedactOptions_BoolMask:
				fd.BoolMask = v.BoolMask // true or false
			case *redact.RedactOptions_BytesMask:
				fd.BytesMask = v.BytesMask // e.g., "[REDACTED]"
			case *redact.RedactOptions_EnumMask:
				fd.EnumMask = v.EnumMask // enum value as int32
			}
		}

		fields = append(fields, fd)
	}

	return &messageDesc{
		Name:   msg.GoIdent.GoName, // Go type name for the message
		Fields: fields,
	}
}

// protocVersion extracts the protoc compiler version from the plugin request.
// This is included in the generated file header for debugging and compatibility tracking.
// Returns "(unknown)" if version information is not available.
func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	// Format: vMAJOR.MINOR.PATCH[-SUFFIX]
	// Example: v3.21.12, v4.25.0-rc1
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

type messageDesc struct {
	Name   string       // Message name (e.g., "User")
	Fields []*fieldDesc // Fields in the message
}

type fieldDesc struct {
	GoName            string // Go field name (e.g., "Email")
	JSONName          string // JSON field name (e.g., "email")
	Redact            bool   // Whether this field should be redacted
	IsMessage         bool   // Whether this field is a proto message type
	IsRepeated        bool   // Whether this field is a repeated field
	IsInteger         bool   // Whether this field is an integer type (int32, int64, uint32, etc.)
	IsFloat           bool   // Whether this field is a float/double type
	IsBool            bool   // Whether this field is a bool type
	IsBytes           bool   // Whether this field is a bytes type
	IsEnum            bool   // Whether this field is an enum type
	IsMap             bool   // Whether this field is a map type
	IsOneof           bool   // Whether this field is part of a oneof
	MapValueIsMessage bool   // Whether the map value is a message type

	// Custom mask values for scalar types (other types use Go zero values)
	StringMask string  // Custom mask for string fields, default "*"
	IntMask    int64   // Custom mask for integer fields, default 0
	DoubleMask float64 // Custom mask for float/double fields, default 0
	BoolMask   bool    // Custom mask for bool fields, default false
	BytesMask  string  // Custom mask for bytes fields, default ""
	EnumMask   int32   // Custom mask for enum fields, default 0
}

func genMessage(g *protogen.GeneratedFile, m *messageDesc) {
	// redact returns a map representation with sensitive fields masked.
	// This is used internally for recursive redaction without JSON escaping issues.
	g.P("func (x *", m.Name, ") redact() map[string]any {")
	g.P("	if x == nil {")
	g.P("		return nil")
	g.P("	}")
	g.P("	m := make(map[string]any)")
	for _, f := range m.Fields {
		if f.Redact {
			if f.IsRepeated {
				g.P(`	m["`, f.JSONName, `"] = []any{}`)
			} else if f.IsMap {
				g.P(`	m["`, f.JSONName, `"] = map[string]any{}`)
			} else if f.IsMessage {
				if f.IsOneof {
					g.P("	if x.Get", f.GoName, "() != nil {")
					g.P(`		m["`, f.JSONName, `"] = nil`)
					g.P("	}")
				} else {
					g.P(`	m["`, f.JSONName, `"] = nil`)
				}
			} else if f.IsOneof {
				if f.IsBytes {
					g.P("	if x.Get", f.GoName, "() != nil {")
					g.P(`		m["`, f.JSONName, `"] = `, strconv.Quote(f.BytesMask))
					g.P("	}")
				} else if f.IsInteger {
					g.P("	if x.Get", f.GoName, "() != 0 {")
					g.P(`		m["`, f.JSONName, `"] = int64(`, f.IntMask, `)`)
					g.P("	}")
				} else if f.IsFloat {
					g.P("	if x.Get", f.GoName, "() != 0 {")
					g.P(`		m["`, f.JSONName, `"] = float64(`, f.DoubleMask, `)`)
					g.P("	}")
				} else if f.IsBool {
					g.P("	if x.Get", f.GoName, "() {")
					g.P(`		m["`, f.JSONName, `"] = `, f.BoolMask)
					g.P("	}")
				} else if f.IsEnum {
					g.P("	if x.Get", f.GoName, "() != 0 {")
					g.P(`		m["`, f.JSONName, `"] = int32(`, f.EnumMask, `)`)
					g.P("	}")
				} else {
					g.P("	if x.Get", f.GoName, "() != \"\" {")
					g.P(`		m["`, f.JSONName, `"] = `, strconv.Quote(f.StringMask))
					g.P("	}")
				}
			} else if f.IsInteger {
				g.P(`	m["`, f.JSONName, `"] = int64(`, f.IntMask, `)`)
			} else if f.IsFloat {
				g.P(`	m["`, f.JSONName, `"] = float64(`, f.DoubleMask, `)`)
			} else if f.IsBool {
				g.P(`	m["`, f.JSONName, `"] = `, f.BoolMask)
			} else if f.IsBytes {
				g.P(`	m["`, f.JSONName, `"] = `, strconv.Quote(f.BytesMask))
			} else if f.IsEnum {
				g.P(`	m["`, f.JSONName, `"] = int32(`, f.EnumMask, `)`)
			} else {
				g.P(`	m["`, f.JSONName, `"] = `, strconv.Quote(f.StringMask))
			}
		} else if f.IsMap {
			g.P("	if len(x.", f.GoName, ") > 0 {")
			g.P("		mapVal := make(map[string]any)")
			g.P("		for k, v := range x.", f.GoName, " {")
			g.P("			key := ", fmtPackage.Ident("Sprintf"), `("%v", k)`)
			if f.MapValueIsMessage {
				g.P("			if v != nil {")
				g.P("				if r, ok := any(v).(interface{ redact() map[string]any }); ok {")
				g.P("					mapVal[key] = r.redact()")
				g.P("				} else {")
				g.P("					mapVal[key] = ", jsonPackage.Ident("RawMessage"), "(", protojsonPackage.Ident("Format"), "(v))")
				g.P("				}")
				g.P("			}")
			} else {
				g.P("			mapVal[key] = v")
			}
			g.P("		}")
			g.P(`		m["`, f.JSONName, `"] = mapVal`)
			g.P("	}")
		} else if f.IsMessage && f.IsRepeated {
			g.P("	if len(x.", f.GoName, ") > 0 {")
			g.P("		items := make([]any, len(x.", f.GoName, "))")
			g.P("		for i, item := range x.", f.GoName, " {")
			g.P("			if item != nil {")
			g.P("				if r, ok := any(item).(interface{ redact() map[string]any }); ok {")
			g.P("					items[i] = r.redact()")
			g.P("				} else {")
			g.P("					items[i] = ", jsonPackage.Ident("RawMessage"), "(", protojsonPackage.Ident("Format"), "(item))")
			g.P("				}")
			g.P("			}")
			g.P("		}")
			g.P(`		m["`, f.JSONName, `"] = items`)
			g.P("	}")
		} else if f.IsRepeated {
			g.P("	if len(x.", f.GoName, ") > 0 {")
			g.P(`		m["`, f.JSONName, `"] = x.`, f.GoName)
			g.P("	}")

		} else if f.IsOneof {
			if f.IsMessage {
				g.P("	if x.Get", f.GoName, "() != nil {")
				g.P("		if r, ok := any(x.Get", f.GoName, "()).(interface{ redact() map[string]any }); ok {")
				g.P(`			m["`, f.JSONName, `"] = r.redact()`)
				g.P("		} else {")
				g.P(`			m["`, f.JSONName, `"] = `, jsonPackage.Ident("RawMessage"), `(`, protojsonPackage.Ident("Format"), `(x.Get`, f.GoName, `()))`)
				g.P("		}")
				g.P("	}")
			} else {
				g.P(`	m["`, f.JSONName, `"] = x.Get`, f.GoName, `()`)
			}
		} else if f.IsMessage {
			g.P("	if x.", f.GoName, " != nil {")
			g.P("		if r, ok := any(x.", f.GoName, ").(interface{ redact() map[string]any }); ok {")
			g.P(`			m["`, f.JSONName, `"] = r.redact()`)
			g.P("		} else {")
			g.P(`			m["`, f.JSONName, `"] = `, jsonPackage.Ident("RawMessage"), `(`, protojsonPackage.Ident("Format"), `(x.`, f.GoName, `))`)
			g.P("		}")
			g.P("	}")
		} else {
			g.P(`	m["`, f.JSONName, `"] = x.`, f.GoName)
		}
	}
	g.P("	return m")
	g.P("}")
	g.P()
	g.P("// Redact returns a redacted JSON string representation of ", m.Name, ".")
	g.P("// Sensitive fields are masked to prevent accidental logging of sensitive data.")
	g.P("// This method implements the Redacter interface for Kratos logging middleware.")
	g.P("func (x *", m.Name, ") Redact() string {")
	g.P("	if x == nil {")
	g.P(`		return "{}"`)
	g.P("	}")
	g.P("	b, _ := ", jsonPackage.Ident("Marshal"), "(x.redact())")
	g.P("	return string(b)")
	g.P("}")
	g.P()
}

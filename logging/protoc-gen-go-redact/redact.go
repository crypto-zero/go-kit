package main

import (
	"fmt"

	redact "github.com/crypto-zero/go-kit/proto/kit/redact/v1"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

// generateFile generates a _redact.pb.go file containing Redact() method implementations.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Messages) == 0 {
		return nil
	}

	// Phase 1: Collect messages that directly have redact fields
	messagesNeedRedact := make(map[string]bool)
	collectMessagesWithDirectRedact(file.Messages, messagesNeedRedact)

	// Phase 2: Propagate - mark messages that reference redactable messages
	propagateRedactRequirement(file.Messages, messagesNeedRedact)

	// Phase 3: Build message descriptors for code generation
	var messagesWithRedact []*messageDesc
	collectMessagesForGeneration(file.Messages, messagesNeedRedact, &messagesWithRedact)

	if len(messagesWithRedact) == 0 {
		return nil
	}

	return writeGeneratedFile(gen, file, messagesWithRedact)
}

// writeGeneratedFile creates the generated file with imports and message methods.
func writeGeneratedFile(gen *protogen.Plugin, file *protogen.File, messages []*messageDesc) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_redact.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// File header
	g.P("// Code generated by protoc-gen-go-redact. DO NOT EDIT.")
	g.P("// versions:")
	g.P(fmt.Sprintf("// - protoc-gen-go-redact %s", release))
	g.P("// - protoc             ", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Check if we need fmt package (for map key conversion)
	needsFmt := false
	for _, md := range messages {
		for _, fd := range md.Fields {
			if fd.IsMap && !fd.Redact {
				needsFmt = true
				break
			}
		}
		if needsFmt {
			break
		}
	}

	// Imports
	g.P("import (")
	g.P(`	"encoding/json"`)
	if needsFmt {
		g.P(`	"fmt"`)
	}
	g.P()
	g.P(`	"google.golang.org/protobuf/encoding/protojson"`)
	g.P(")")
	g.P()

	// Generate methods for each message
	for _, md := range messages {
		g.P(md.execute())
	}

	return g
}

// collectMessagesWithDirectRedact finds all messages that have fields directly marked with redact option.
func collectMessagesWithDirectRedact(messages []*protogen.Message, result map[string]bool) {
	for _, msg := range messages {
		if hasDirectRedactField(msg) {
			result[string(msg.Desc.FullName())] = true
		}
		collectMessagesWithDirectRedact(msg.Messages, result)
	}
}

// hasDirectRedactField checks if a message has any field directly marked with redact option.
func hasDirectRedactField(msg *protogen.Message) bool {
	for _, field := range msg.Fields {
		if opts := getRedactOptions(field); opts != nil && opts.GetRedact() {
			return true
		}
	}
	return false
}

// getRedactOptions extracts RedactOptions from a field if present.
func getRedactOptions(field *protogen.Field) *redact.RedactOptions {
	opts := field.Desc.Options().(*descriptorpb.FieldOptions)
	if opts == nil || !proto.HasExtension(opts, redact.E_Redact) {
		return nil
	}
	return proto.GetExtension(opts, redact.E_Redact).(*redact.RedactOptions)
}

// propagateRedactRequirement propagates the redact requirement up the message tree.
// If a message contains a field that references a message needing redact, it also needs redact.
func propagateRedactRequirement(messages []*protogen.Message, needsRedact map[string]bool) {
	// Keep iterating until no changes (fixed point)
	for changed := true; changed; {
		changed = false
		propagateForMessages(messages, needsRedact, &changed)
	}
}

func propagateForMessages(messages []*protogen.Message, needsRedact map[string]bool, changed *bool) {
	for _, msg := range messages {
		msgName := string(msg.Desc.FullName())

		// If not already marked, check if any message field references a redactable message
		if !needsRedact[msgName] {
			for _, field := range msg.Fields {
				if field.Desc.Kind() == protoreflect.MessageKind {
					if needsRedact[string(field.Desc.Message().FullName())] {
						needsRedact[msgName] = true
						*changed = true
						break
					}
				}
			}
		}

		// Recursively process nested messages
		propagateForMessages(msg.Messages, needsRedact, changed)
	}
}

// collectMessagesForGeneration collects messages that need Redact() method generation.
func collectMessagesForGeneration(messages []*protogen.Message, needsRedact map[string]bool, result *[]*messageDesc) {
	for _, msg := range messages {
		if needsRedact[string(msg.Desc.FullName())] {
			*result = append(*result, buildMessageDesc(msg))
		}
		collectMessagesForGeneration(msg.Messages, needsRedact, result)
	}
}

// buildMessageDesc builds a messageDesc for code generation.
func buildMessageDesc(msg *protogen.Message) *messageDesc {
	fields := make([]*fieldDesc, 0, len(msg.Fields))

	for _, field := range msg.Fields {
		kind := field.Desc.Kind()
		isMap := field.Desc.IsMap()

		fd := &fieldDesc{
			GoName:     field.GoName,
			JSONName:   string(field.Desc.JSONName()),
			IsMessage:  kind == protoreflect.MessageKind && !isMap,
			IsRepeated: field.Desc.IsList() && !isMap,
			IsNumeric:  isIntegerKind(kind),
			IsFloat:    isFloatKind(kind),
			IsBool:     kind == protoreflect.BoolKind,
			IsBytes:    kind == protoreflect.BytesKind,
			IsEnum:     kind == protoreflect.EnumKind,
			IsMap:      isMap,
			// Default mask values
			StringMask: "*",
			IntMask:    0,
			DoubleMask: 0,
			BoolMask:   false,
			BytesMask:  "",
			EnumMask:   0,
		}

		// Check if map value is a message type
		if isMap {
			mapValue := field.Desc.MapValue()
			fd.MapValueIsMessage = mapValue.Kind() == protoreflect.MessageKind
		}

		if opts := getRedactOptions(field); opts != nil && opts.GetRedact() {
			fd.Redact = true
			// Parse custom mask based on oneof type
			switch v := opts.GetMaskValue().(type) {
			case *redact.RedactOptions_StringMask:
				fd.StringMask = v.StringMask
			case *redact.RedactOptions_IntMask:
				fd.IntMask = v.IntMask
			case *redact.RedactOptions_DoubleMask:
				fd.DoubleMask = v.DoubleMask
			case *redact.RedactOptions_BoolMask:
				fd.BoolMask = v.BoolMask
			case *redact.RedactOptions_BytesMask:
				fd.BytesMask = v.BytesMask
			case *redact.RedactOptions_EnumMask:
				fd.EnumMask = v.EnumMask
			}
		}

		fields = append(fields, fd)
	}

	return &messageDesc{
		Name:   msg.GoIdent.GoName,
		Fields: fields,
	}
}

// isIntegerKind returns true if the kind is an integer type.
func isIntegerKind(kind protoreflect.Kind) bool {
	switch kind {
	case protoreflect.Int32Kind, protoreflect.Int64Kind,
		protoreflect.Uint32Kind, protoreflect.Uint64Kind,
		protoreflect.Sint32Kind, protoreflect.Sint64Kind,
		protoreflect.Fixed32Kind, protoreflect.Fixed64Kind,
		protoreflect.Sfixed32Kind, protoreflect.Sfixed64Kind:
		return true
	}
	return false
}

// isFloatKind returns true if the kind is a float/double type.
func isFloatKind(kind protoreflect.Kind) bool {
	switch kind {
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		return true
	}
	return false
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}
